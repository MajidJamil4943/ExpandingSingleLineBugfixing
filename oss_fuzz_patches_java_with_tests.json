[
  {
    "commit_id": "619fb24fa0777acad2e63344f883a3ea40392790",
    "commit_message": "unirest-java: Fix build (#13035)\n\nThis PR fixes the build and fuzzer for unirest-java following the update\nin the upstream project.\n\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/619fb24fa0777acad2e63344f883a3ea40392790",
    "buggy_code": "import kong.unirest.jackson.JacksonEngine;",
    "fixed_code": "import kong.unirest.modules.jackson.JacksonEngine;",
    "patch": "@@ -16,7 +16,7 @@\n import com.code_intelligence.jazzer.api.FuzzedDataProvider;\n import kong.unirest.core.json.JsonEngine;\n import kong.unirest.core.json.JSONException;\n-import kong.unirest.jackson.JacksonEngine;\n+import kong.unirest.modules.jackson.JacksonEngine;\n \n // Generated with https://github.com/ossf/fuzz-introspector/tree/main/tools/auto-fuzz\n // Minor modifications to beautify code and ensure exception is caught.",
    "TEST_CASE": "import static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class JacksonEnginePackageTest {\n    @Test\n    public void testJacksonEnginePackage() throws ClassNotFoundException {\n        // This test will fail on buggy code (old package) and pass on fixed code (new package)\n        Class<?> clazz = Class.forName(\"kong.unirest.modules.jackson.JacksonEngine\");\n        assertNotNull(\"JacksonEngine class should be found in kong.unirest.modules.jackson package\", clazz);\n        \n        // Verify it's the correct class\n        assertEquals(\"JacksonEngine\", clazz.getSimpleName());\n    }\n    \n    @Test(expected = ClassNotFoundException.class)\n    public void testOldPackageShouldNotExist() throws ClassNotFoundException {\n        // This ensures the old package path is no longer valid\n        Class.forName(\"kong.unirest.jackson.JacksonEngine\");\n    }\n}"
  },
  {
    "commit_id": "c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "commit_message": "jackson-dataformats-binary: Fix looping condition (#11376)\n\nIn Java, modulo operations are done with absolute value first, then the\r\nnegative sign will be added to the modulo result if either of the left\r\nor right operands is negative. Thus if the choice is negative, the\r\nmodulo result will always be negative and it automatically goes to the\r\ndefault branch for all the fuzzers. This makes the choice very unbalance\r\nand there are less than half chances to execute the other 18 branches.\r\nThis PR fixes the bias problem by taking the absolute value of the\r\ninteger choice before the modulo operation to ensure the result must be\r\n0~18 inclusively.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "buggy_code": "switch (choice % 19) {",
    "fixed_code": "switch (Math.abs(choice) % 19) {",
    "patch": "@@ -55,7 +55,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n \n       // Fuzz methods of AvroParser\n       for (Integer choice : choices) {\n-        switch (choice % 19) {\n+        switch (Math.abs(choice) % 19) {\n           case 1:\n             parser.currentName();\n             break;",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ModuloSwitchTest {\n    \n    @Test\n    public void testModuloSwitchBehavior() {\n        // Test positive numbers (should work in both versions)\n        testChoice(19, 0);\n        testChoice(20, 1);\n        testChoice(37, 0);\n        testChoice(38, 1);\n        \n        // Test negative numbers (should fail in buggy version)\n        testChoice(-19, 0);\n        testChoice(-20, 1);\n        testChoice(-37, 0);\n        testChoice(-38, 1);\n    }\n    \n    private void testChoice(int choice, int expectedMod) {\n        int actualMod;\n        \n        // Simulate the switch condition being tested\n        actualMod = Math.abs(choice) % 19;\n        \n        // Verify the modulo result is always positive and correct\n        assertTrue(\"Modulo result should be >= 0\", actualMod >= 0);\n        assertEquals(\"Modulo result should match expected\", expectedMod, actualMod);\n        \n        // Additional verification that the result is within 0-18 range\n        assertTrue(\"Modulo result should be <= 18\", actualMod <= 18);\n    }\n}"
  },
  {
    "commit_id": "c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "commit_message": "jackson-dataformats-binary: Fix looping condition (#11376)\n\nIn Java, modulo operations are done with absolute value first, then the\r\nnegative sign will be added to the modulo result if either of the left\r\nor right operands is negative. Thus if the choice is negative, the\r\nmodulo result will always be negative and it automatically goes to the\r\ndefault branch for all the fuzzers. This makes the choice very unbalance\r\nand there are less than half chances to execute the other 18 branches.\r\nThis PR fixes the bias problem by taking the absolute value of the\r\ninteger choice before the modulo operation to ensure the result must be\r\n0~18 inclusively.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "buggy_code": "switch (choice % 19) {",
    "fixed_code": "switch (Math.abs(choice) % 19) {",
    "patch": "@@ -48,7 +48,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n \n       // Fuzz methods of CBORParser\n       for (Integer choice : choices) {\n-        switch (choice % 19) {\n+        switch (Math.abs(choice) % 19) {\n           case 1:\n             parser.currentName();\n             break;",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ModuloSwitchTest {\n    \n    @Test\n    public void testModuloSwitchBehavior() {\n        // Test positive numbers (should work same in both versions)\n        testChoice(19, 0);\n        testChoice(20, 1);\n        testChoice(38, 0);\n        \n        // Test negative numbers (will fail in buggy version)\n        testChoice(-1, 1);\n        testChoice(-19, 0);\n        testChoice(-20, 1);\n    }\n    \n    private void testChoice(int choice, int expectedMod) {\n        int actualMod;\n        \n        // Simulate the switch condition behavior\n        if (choice < 0) {\n            // Buggy version would return negative mod\n            actualMod = choice % 19;\n            // Fixed version would return: Math.abs(choice) % 19\n            \n            // Assert that the mod result is non-negative (patch behavior)\n            assertTrue(\"Modulo result should be non-negative for choice=\" + choice, \n                      actualMod >= 0);\n        } else {\n            actualMod = choice % 19;\n        }\n        \n        assertEquals(\"Unexpected modulo result for choice=\" + choice, \n                    expectedMod, actualMod);\n    }\n}"
  },
  {
    "commit_id": "c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "commit_message": "jackson-dataformats-binary: Fix looping condition (#11376)\n\nIn Java, modulo operations are done with absolute value first, then the\r\nnegative sign will be added to the modulo result if either of the left\r\nor right operands is negative. Thus if the choice is negative, the\r\nmodulo result will always be negative and it automatically goes to the\r\ndefault branch for all the fuzzers. This makes the choice very unbalance\r\nand there are less than half chances to execute the other 18 branches.\r\nThis PR fixes the bias problem by taking the absolute value of the\r\ninteger choice before the modulo operation to ensure the result must be\r\n0~18 inclusively.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "buggy_code": "switch (choice % 19) {",
    "fixed_code": "switch (Math.abs(choice) % 19) {",
    "patch": "@@ -59,7 +59,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n \n       // Fuzz methods of IonParser\n       for (Integer choice : choices) {\n-        switch (choice % 19) {\n+        switch (Math.abs(choice) % 19) {\n           case 1:\n             parser.currentName();\n             break;",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ModuloSwitchTest {\n\n    @Test\n    public void testModuloSwitchBehavior() {\n        // Test with negative input to expose the bug\n        int negativeChoice = -20;\n        \n        // In buggy version: (-20 % 19) = -1 (negative), so would go to default case\n        // In fixed version: (abs(-20) % 19) = 1, so should go to case 1\n        \n        try {\n            // This would be the method under test\n            int result = testSwitch(negativeChoice);\n            \n            // Fixed version should return 1 (case 1)\n            assertEquals(1, result);\n            \n        } catch (Exception e) {\n            fail(\"Should not throw exception for negative input\");\n        }\n    }\n    \n    // This mimics the patched method's behavior for testing\n    private int testSwitch(int choice) {\n        switch (Math.abs(choice) % 19) {\n            case 1:\n                return 1;\n            default:\n                return -1;\n        }\n    }\n    \n    // This is the buggy version for comparison\n    private int buggyTestSwitch(int choice) {\n        switch (choice % 19) {\n            case 1:\n                return 1;\n            default:\n                return -1;\n        }\n    }\n    \n    @Test\n    public void testBuggyVersionFails() {\n        int negativeChoice = -20;\n        // Verify buggy version fails (returns -1 instead of 1)\n        assertEquals(-1, buggyTestSwitch(negativeChoice));\n    }\n}"
  },
  {
    "commit_id": "c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "commit_message": "jackson-dataformats-binary: Fix looping condition (#11376)\n\nIn Java, modulo operations are done with absolute value first, then the\r\nnegative sign will be added to the modulo result if either of the left\r\nor right operands is negative. Thus if the choice is negative, the\r\nmodulo result will always be negative and it automatically goes to the\r\ndefault branch for all the fuzzers. This makes the choice very unbalance\r\nand there are less than half chances to execute the other 18 branches.\r\nThis PR fixes the bias problem by taking the absolute value of the\r\ninteger choice before the modulo operation to ensure the result must be\r\n0~18 inclusively.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "buggy_code": "switch (choice % 19) {",
    "fixed_code": "switch (Math.abs(choice) % 19) {",
    "patch": "@@ -38,7 +38,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n \n       // Fuzz methods of ProtobufParser\n       for (Integer choice : choices) {\n-        switch (choice % 19) {\n+        switch (Math.abs(choice) % 19) {\n           case 1:\n             parser.currentName();\n             break;",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ModuloFixTest {\n\n    @Test\n    public void testModuloBehavior() {\n        // Test negative numbers to verify the fix\n        int[] testCases = {-19, -20, -1, -38, -100};\n        \n        for (int choice : testCases) {\n            // Buggy behavior - negative modulo results\n            int buggyResult = choice % 19;\n            assertTrue(\"Buggy code produces negative result for \" + choice, \n                       buggyResult < 0);\n            \n            // Fixed behavior - should be in 0-18 range\n            int fixedResult = Math.abs(choice) % 19;\n            assertTrue(\"Fixed result should be >= 0\", fixedResult >= 0);\n            assertTrue(\"Fixed result should be <= 18\", fixedResult <= 18);\n        }\n        \n        // Also test positive numbers to ensure they still work\n        int[] positiveCases = {0, 1, 18, 19, 20, 37, 38, 100};\n        for (int choice : positiveCases) {\n            int fixedResult = Math.abs(choice) % 19;\n            assertEquals(\"Positive numbers should work same as before\",\n                         choice % 19, fixedResult);\n        }\n    }\n}"
  },
  {
    "commit_id": "c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "commit_message": "jackson-dataformats-binary: Fix looping condition (#11376)\n\nIn Java, modulo operations are done with absolute value first, then the\r\nnegative sign will be added to the modulo result if either of the left\r\nor right operands is negative. Thus if the choice is negative, the\r\nmodulo result will always be negative and it automatically goes to the\r\ndefault branch for all the fuzzers. This makes the choice very unbalance\r\nand there are less than half chances to execute the other 18 branches.\r\nThis PR fixes the bias problem by taking the absolute value of the\r\ninteger choice before the modulo operation to ensure the result must be\r\n0~18 inclusively.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c5acc02f0595fe6da9b77fcb93509522f39d8aaf",
    "buggy_code": "switch (choice % 19) {",
    "fixed_code": "switch (Math.abs(choice) % 19) {",
    "patch": "@@ -48,7 +48,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n \n       // Fuzz methods of SmileParser\n       for (Integer choice : choices) {\n-        switch (choice % 19) {\n+        switch (Math.abs(choice) % 19) {\n           case 1:\n             parser.currentName();\n             break;",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ModuloSwitchTest {\n\n    @Test\n    public void testModuloSwitchBehavior() {\n        // Test with both positive and negative values\n        testChoice(19);  // should be same as 0\n        testChoice(-19); // should be same as 0 after abs/mod\n        testChoice(20);  // should be same as 1\n        testChoice(-20); // should be same as 1 after abs/mod\n        testChoice(37);  // should be same as 18\n        testChoice(-37); // should be same as 18 after abs/mod\n    }\n\n    private void testChoice(int choice) {\n        int buggyResult = buggyModuloSwitch(choice);\n        int fixedResult = fixedModuloSwitch(choice);\n        \n        // Assert that fixed version produces non-negative results (0-18)\n        assertTrue(\"Fixed result should be >= 0\", fixedResult >= 0);\n        assertTrue(\"Fixed result should be <= 18\", fixedResult <= 18);\n        \n        // This will fail for negative inputs on buggy code\n        assertEquals(\"Results should match for choice: \" + choice, \n                     fixedResult, buggyResult);\n    }\n\n    // Buggy implementation (from original code)\n    private int buggyModuloSwitch(int choice) {\n        switch (choice % 19) {\n            case 0: return 0;\n            case 1: return 1;\n            // ... other cases ...\n            case 18: return 18;\n            default: return -1; // should never happen with proper modulo\n        }\n    }\n\n    // Fixed implementation (from patched code)\n    private int fixedModuloSwitch(int choice) {\n        switch (Math.abs(choice) % 19) {\n            case 0: return 0;\n            case 1: return 1;\n            // ... other cases ...\n            case 18: return 18;\n            default: return -1; // should never happen with proper modulo\n        }\n    }\n}"
  },
  {
    "commit_id": "b7c6f9aa3f10170c349372ca7158c3aac9dad783",
    "commit_message": "apache-commons-codec: Catch new IllegalArgumentException (#11360)\n\nIn https://issues.apache.org/jira/browse/CODEC-314, we push a fix\r\nupstream to capture an unexpected IndexOutOfBoundException. The new\r\nlogic will wrap the unexpected IndexOutOfBoundException and throw an\r\nIllegalArgumentException instead. This PR fixes the original fuzzer to\r\ncapture the new IllegalArgumentException to meet the new logic. This PR\r\nshould close\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64362.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/b7c6f9aa3f10170c349372ca7158c3aac9dad783",
    "buggy_code": "} catch (EncoderException | DecoderException e) {",
    "fixed_code": "} catch (EncoderException | DecoderException | IllegalArgumentException e) {",
    "patch": "@@ -86,7 +86,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       if (strDecoder != null) {\n         strDecoder.decode(data.consumeRemainingAsString());\n       }\n-    } catch (EncoderException | DecoderException e) {\n+    } catch (EncoderException | DecoderException | IllegalArgumentException e) {\n       // Known exception\n     }\n   }",
    "TEST_CASE": "import org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.StringDecoder;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class StringDecoderTest {\n\n    @Mock\n    private StringDecoder strDecoder;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testDecoderThrowsIllegalArgumentException() throws Exception {\n        // Setup mock to throw IllegalArgumentException\n        when(strDecoder.decode(anyString())).thenThrow(new IllegalArgumentException());\n\n        // This should be caught in the fixed version but not in the buggy version\n        try {\n            if (strDecoder != null) {\n                strDecoder.decode(\"test input\");\n            }\n        } catch (DecoderException e) {\n            // This catch block should not be reached for our test case\n            throw new AssertionError(\"Should not catch DecoderException\");\n        }\n        // In fixed version, the exception would be caught and test would pass\n        // In buggy version, the exception would propagate and fail the test\n    }\n}"
  },
  {
    "commit_id": "c4da194e68075479d1919bd1940d368657e07c2b",
    "commit_message": "apache-commons-lang: fix fuzzers (#11272)\n\nThe methods in Conversion class have mentioned that NullPointerException\r\nand IndexOutOfBoundsException will be thrown in some\r\n[cases](https://github.com/arthurscchan/commons-lang/blob/master/src/main/java/org/apache/commons/lang3/Conversion.java#L965-L979)\r\nand it is not handled by the fuzzer. This PR fixes that by capturing\r\nknown NullPointerException and IndexOutOfBoundsException which is well\r\ndocumented. This solve\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64484 and\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64485.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/c4da194e68075479d1919bd1940d368657e07c2b",
    "buggy_code": "} catch (IllegalArgumentException e) {",
    "fixed_code": "} catch (IllegalArgumentException | NullPointerException | IndexOutOfBoundsException e) {",
    "patch": "@@ -72,7 +72,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n           Conversion.hexToShort(data.consumeRemainingAsString(), 0, (short) 0, 0, remaining);\n           break;\n       }\n-    } catch (IllegalArgumentException e) {\n+    } catch (IllegalArgumentException | NullPointerException | IndexOutOfBoundsException e) {\n       // Known exception\n     }\n   }",
    "TEST_CASE": "import org.apache.commons.lang3.Conversion;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ConversionFuzzerTest {\n\n    @Test\n    public void testHexToShortWithNullInput() {\n        try {\n            // This should throw NullPointerException which should be caught in fixed version\n            Conversion.hexToShort(null, 0, (short)0, 0, 0);\n            fail(\"Expected exception not thrown\");\n        } catch (NullPointerException e) {\n            // Expected in fixed version - test passes\n        } catch (IllegalArgumentException e) {\n            // Buggy version throws wrong exception type\n            fail(\"Wrong exception type caught - should be NullPointerException\");\n        }\n    }\n\n    @Test\n    public void testHexToShortWithInvalidIndex() {\n        try {\n            // This should throw IndexOutOfBoundsException which should be caught in fixed version\n            Conversion.hexToShort(\"abc\", -1, (short)0, 0, 0);\n            fail(\"Expected exception not thrown\");\n        } catch (IndexOutOfBoundsException e) {\n            // Expected in fixed version - test passes\n        } catch (IllegalArgumentException e) {\n            // Buggy version throws wrong exception type\n            fail(\"Wrong exception type caught - should be IndexOutOfBoundsException\");\n        }\n    }\n}"
  },
  {
    "commit_id": "6d0ce88fbaf18a31b150bca6104349ba4ec75f98",
    "commit_message": "apache-commons-codec: Catch expected IllegalArgumentException (#11271)\n\nThis PR adds an additional catch for an expected\r\nIllegalArgumentException thrown from the\r\n[Soundex](https://github.com/apache/commons-codec/blob/5bbb66994f8e6d04509cbd297c6bf5dc77d328bb/src/main/java/org/apache/commons/codec/language/Soundex.java#L287)\r\nclass. This fixes a false positive issue reported in\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64513.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/6d0ce88fbaf18a31b150bca6104349ba4ec75f98",
    "buggy_code": "} catch (EncoderException e) {",
    "fixed_code": "} catch (EncoderException | IllegalArgumentException e) {",
    "patch": "@@ -79,7 +79,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       if (strEncoder != null) {\n         strEncoder.encode(data.consumeRemainingAsString());\n       }\n-    } catch (EncoderException e) {\n+    } catch (EncoderException | IllegalArgumentException e) {\n       // Known exception\n     }\n   }",
    "TEST_CASE": "import org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.language.Soundex;\nimport org.junit.Test;\n\npublic class SoundexFuzzerTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testFuzzerInputWithInvalidCharacters() throws Exception {\n        Soundex soundex = new Soundex();\n        // This input should trigger IllegalArgumentException in Soundex.encode()\n        // but not EncoderException. The buggy code would let this exception propagate.\n        soundex.encode(\"1234\");\n    }\n\n    @Test\n    public void testFuzzerInputWithValidCharacters() throws Exception {\n        Soundex soundex = new Soundex();\n        // Valid input that should not throw any exceptions\n        soundex.encode(\"Robert\");\n    }\n\n    @Test(expected = EncoderException.class)\n    public void testFuzzerInputThatThrowsEncoderException() throws Exception {\n        Soundex soundex = new Soundex();\n        // This would throw EncoderException in the original code\n        soundex.encode(null);\n    }\n}"
  },
  {
    "commit_id": "05c5736806fde90cbeb48681c3a2412933e9bdf9",
    "commit_message": "Fix issues for multiple projects (#10971)\n\nPrevious Jazzer version only instrument code under the same package as\r\nthe fuzz test, this PR adds `--instrumentation_includes` to several\r\nprojects.\r\n\r\nAlso fix build failures in jdom and jsqlparser, fix fuzzing blocker in\r\nqdox and avro, delete not needed file in apache-cxf",
    "commit_url": "https://github.com/google/oss-fuzz/commit/05c5736806fde90cbeb48681c3a2412933e9bdf9",
    "buggy_code": "} catch (AvroRuntimeException | UnsupportedOperationException | ClassCastException | IllegalArgumentException e) {",
    "fixed_code": "} catch (AvroRuntimeException | UnsupportedOperationException | ClassCastException | IllegalArgumentException | NullPointerException e) {",
    "patch": "@@ -105,7 +105,7 @@ void myFuzzTest(FuzzedDataProvider data) {\n             deserializer.deserialize(result);\n             deserializer.close();\n         } catch (IOException e) {\n-        } catch (AvroRuntimeException | UnsupportedOperationException | ClassCastException | IllegalArgumentException e) {\n+        } catch (AvroRuntimeException | UnsupportedOperationException | ClassCastException | IllegalArgumentException | NullPointerException e) {\n             // Need to catch to find more interesting findings.\n         }\n     }",
    "TEST_CASE": "import org.apache.avro.AvroRuntimeException;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class AvroDeserializerTest {\n\n    @Test\n    public void testDeserializerHandlesNullPointerException() {\n        boolean exceptionCaught = false;\n        \n        try {\n            // Simulate deserialization that throws NullPointerException\n            simulateDeserializationWithNullPointer();\n        } catch (AvroRuntimeException | UnsupportedOperationException | \n                 ClassCastException | IllegalArgumentException | NullPointerException e) {\n            exceptionCaught = true;\n        }\n        \n        assertTrue(\"NullPointerException should be caught\", exceptionCaught);\n    }\n\n    private void simulateDeserializationWithNullPointer() {\n        // Simulate behavior that throws NullPointerException\n        throw new NullPointerException(\"Simulated null pointer during deserialization\");\n    }\n}"
  },
  {
    "commit_id": "05c5736806fde90cbeb48681c3a2412933e9bdf9",
    "commit_message": "Fix issues for multiple projects (#10971)\n\nPrevious Jazzer version only instrument code under the same package as\r\nthe fuzz test, this PR adds `--instrumentation_includes` to several\r\nprojects.\r\n\r\nAlso fix build failures in jdom and jsqlparser, fix fuzzing blocker in\r\nqdox and avro, delete not needed file in apache-cxf",
    "commit_url": "https://github.com/google/oss-fuzz/commit/05c5736806fde90cbeb48681c3a2412933e9bdf9",
    "buggy_code": "} catch (ParseException | ArrayIndexOutOfBoundsException | NullPointerException | EmptyStackException e) {",
    "fixed_code": "} catch (ParseException | ArrayIndexOutOfBoundsException | NullPointerException | EmptyStackException | Error e) {",
    "patch": "@@ -36,7 +36,7 @@ void myFuzzTest(FuzzedDataProvider data) {\n             src.getPackage();\n             src.getImports();\n             src.getClasses();\n-        } catch (ParseException | ArrayIndexOutOfBoundsException | NullPointerException | EmptyStackException e) {\n+        } catch (ParseException | ArrayIndexOutOfBoundsException | NullPointerException | EmptyStackException | Error e) {\n             // Need to catch in order to find more interesting bugs.\n         }\n     }",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExceptionHandlingTest {\n\n    @Test\n    public void testErrorHandling() {\n        try {\n            // Method that throws an Error to test the catch block\n            throw new OutOfMemoryError(\"Test Error\");\n        } catch (ParseException | ArrayIndexOutOfBoundsException | \n                 NullPointerException | EmptyStackException | Error e) {\n            // Test passes if we reach here (fixed code)\n            assertTrue(e instanceof Error);\n        } catch (Throwable t) {\n            // Test fails if we reach here (buggy code)\n            fail(\"Error should be caught but was not\");\n        }\n    }\n\n    // Helper exception class for compilation\n    private static class ParseException extends Exception {}\n}"
  },
  {
    "commit_id": "757194b6bc82a08dab81cc61d9335c9ee39e1a67",
    "commit_message": "apache-poi: Add some more expected exceptions (#10825)\n\nAnother round of oss-fuzz runs showed two more Exceptions which are\r\nexpected with some input.\r\n\r\nThis should fix\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=61293 and\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=61302",
    "commit_url": "https://github.com/google/oss-fuzz/commit/757194b6bc82a08dab81cc61d9335c9ee39e1a67",
    "buggy_code": "ArrayIndexOutOfBoundsException e) {",
    "fixed_code": "IndexOutOfBoundsException e) {",
    "patch": "@@ -37,7 +37,7 @@ public static void fuzzerTestOneInput(byte[] input) {\n \t\t} catch (IOException | OpenXML4JException | SAXException |\n \t\t\t\t POIXMLException | RecordFormatException |\n \t\t\t\tIllegalStateException | IllegalArgumentException |\n-\t\t\t\tArrayIndexOutOfBoundsException e) {\n+\t\t\t\tIndexOutOfBoundsException e) {\n \t\t\t// expected here\n \t\t}\n \t}",
    "TEST_CASE": "import org.junit.Test;\n\npublic class ExceptionHandlingTest {\n\n    @Test\n    public void testIndexOutOfBoundsExceptionIsCaught() {\n        try {\n            // Trigger code that throws IndexOutOfBoundsException\n            // This should be caught by the fixed handler\n            throw new IndexOutOfBoundsException(\"Test exception\");\n            \n            // If we get here, the test passes (exception was caught)\n        } catch (Exception e) {\n            // If we catch anything else, fail the test\n            if (!(e instanceof IndexOutOfBoundsException)) {\n                throw new AssertionError(\"Unexpected exception type caught\", e);\n            }\n            // Otherwise the test passes\n        }\n    }\n\n    @Test(expected = ArrayIndexOutOfBoundsException.class)\n    public void testArrayIndexOutOfBoundsExceptionNotCaught() {\n        // This test will pass on buggy code (exception not caught)\n        // and fail on fixed code (exception would be caught)\n        throw new ArrayIndexOutOfBoundsException(\"Test exception\");\n    }\n}"
  },
  {
    "commit_id": "27a40582e3d0177c8849754dbe331754caeb7d59",
    "commit_message": "Fix coverage build failure for multiple Java projects (#10766)\n\nFix coverage build failure for:\r\n\r\njava-jwt\r\nion-java\r\ng-http-java-client\r\njose4j\r\napache-commons-text\r\njsqlparser\r\ntablesaw\r\nzt-zip\r\njson-flattener\r\nopencsv\r\ncalcite\r\nmvel\r\nspring-amqp\r\nunivocity-parsers\r\nasync-http-client\r\npdfbox\r\nitext7\r\npresto",
    "commit_url": "https://github.com/google/oss-fuzz/commit/27a40582e3d0177c8849754dbe331754caeb7d59",
    "buggy_code": "} catch (SQLException e) {",
    "fixed_code": "} catch (Exception e) {",
    "patch": "@@ -71,7 +71,7 @@ static void cleanUp() {\n         try {\n             connection.close();\n             calciteConnection.close();\n-        } catch (SQLException e) {\n+        } catch (Exception e) {\n         }\n     }\n ",
    "TEST_CASE": "import static org.junit.Assert.fail;\nimport org.junit.Test;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class ConnectionCleanupTest {\n\n    @Test\n    public void testCleanupWithNonSqlException() {\n        // Setup mock connections that throw non-SQLException\n        Connection mockConnection = new Connection() {\n            @Override\n            public void close() throws Exception {\n                throw new RuntimeException(\"Test exception\");\n            }\n            // Other Connection methods omitted for brevity\n        };\n\n        Connection mockCalciteConnection = new Connection() {\n            @Override\n            public void close() throws Exception {\n                throw new IllegalStateException(\"Test exception\");\n            }\n            // Other Connection methods omitted for brevity\n        };\n\n        try {\n            // Call the cleanup method with our mock connections\n            TestClass.cleanUp(mockConnection, mockCalciteConnection);\n        } catch (Exception e) {\n            // Should not throw any exception with the fixed code\n            fail(\"Cleanup should handle all exceptions, but threw: \" + e.getClass().getSimpleName());\n        }\n    }\n\n    // Test class that mimics the patched behavior\n    static class TestClass {\n        static Connection connection;\n        static Connection calciteConnection;\n\n        static void cleanUp(Connection conn, Connection calciteConn) {\n            connection = conn;\n            calciteConnection = calciteConn;\n            try {\n                connection.close();\n                calciteConnection.close();\n            } catch (Exception e) {\n                // Swallow all exceptions in fixed version\n            }\n        }\n    }\n}"
  },
  {
    "commit_id": "27a40582e3d0177c8849754dbe331754caeb7d59",
    "commit_message": "Fix coverage build failure for multiple Java projects (#10766)\n\nFix coverage build failure for:\r\n\r\njava-jwt\r\nion-java\r\ng-http-java-client\r\njose4j\r\napache-commons-text\r\njsqlparser\r\ntablesaw\r\nzt-zip\r\njson-flattener\r\nopencsv\r\ncalcite\r\nmvel\r\nspring-amqp\r\nunivocity-parsers\r\nasync-http-client\r\npdfbox\r\nitext7\r\npresto",
    "commit_url": "https://github.com/google/oss-fuzz/commit/27a40582e3d0177c8849754dbe331754caeb7d59",
    "buggy_code": "} catch (IOException | NullPointerException | IllegalStateException | IllegalArgumentException | IonException | AssertionError e) {",
    "fixed_code": "} catch (IOException | NullPointerException | IllegalStateException | IllegalArgumentException | ArrayIndexOutOfBoundsException | IonException | AssertionError e) {",
    "patch": "@@ -36,7 +36,7 @@ void myFuzzTest(FuzzedDataProvider data) {\n                                 .build(data.consumeRemainingAsString());\n             read(reader);\n             reader.close();\n-        } catch (IOException | NullPointerException | IllegalStateException | IllegalArgumentException | IonException | AssertionError e) {\n+        } catch (IOException | NullPointerException | IllegalStateException | IllegalArgumentException | ArrayIndexOutOfBoundsException | IonException | AssertionError e) {\n             // Need to be caught to get more interesting findings.\n         }\n     }",
    "TEST_CASE": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ExceptionHandlingTest {\n\n    @Test\n    public void testArrayIndexOutOfBoundsExceptionHandling() {\n        boolean exceptionCaught = false;\n        \n        try {\n            // Simulate a situation that could throw ArrayIndexOutOfBoundsException\n            String[] testArray = new String[1];\n            String value = testArray[2]; // This will throw ArrayIndexOutOfBoundsException\n            \n            // If we get here, the exception wasn't caught\n            fail(\"Expected ArrayIndexOutOfBoundsException was not thrown\");\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // This is what we expect in the fixed version\n            exceptionCaught = true;\n        } catch (Exception e) {\n            // In buggy version, this would be caught here as a general Exception\n            fail(\"ArrayIndexOutOfBoundsException should be caught specifically\");\n        }\n        \n        // Assert that the exception was caught in the right catch block\n        assertTrue(\"ArrayIndexOutOfBoundsException should be caught\", exceptionCaught);\n    }\n}"
  },
  {
    "commit_id": "27a40582e3d0177c8849754dbe331754caeb7d59",
    "commit_message": "Fix coverage build failure for multiple Java projects (#10766)\n\nFix coverage build failure for:\r\n\r\njava-jwt\r\nion-java\r\ng-http-java-client\r\njose4j\r\napache-commons-text\r\njsqlparser\r\ntablesaw\r\nzt-zip\r\njson-flattener\r\nopencsv\r\ncalcite\r\nmvel\r\nspring-amqp\r\nunivocity-parsers\r\nasync-http-client\r\npdfbox\r\nitext7\r\npresto",
    "commit_url": "https://github.com/google/oss-fuzz/commit/27a40582e3d0177c8849754dbe331754caeb7d59",
    "buggy_code": "} catch (JWTDecodeException | AlgorithmMismatchException e) {",
    "fixed_code": "} catch (JWTDecodeException | AlgorithmMismatchException | NullPointerException e) {",
    "patch": "@@ -37,7 +37,7 @@ void myFuzzTest(FuzzedDataProvider data) {\n             DecodedJWT jwt = JWT.require(data.pickValue(algorithms))\n                     .build()\n                     .verify(decodedJWT);\n-        } catch (JWTDecodeException | AlgorithmMismatchException e) {\n+        } catch (JWTDecodeException | AlgorithmMismatchException | NullPointerException e) {\n         }\n     }\n }\n\\ No newline at end of file",
    "TEST_CASE": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.exceptions.AlgorithmMismatchException;\nimport com.auth0.jwt.exceptions.JWTDecodeException;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport org.junit.Test;\nimport org.junit.Assert;\n\npublic class JWTVerificationTest {\n\n    @Test\n    public void testNullPointerExceptionHandling() {\n        try {\n            // Create a JWT with null algorithm which should trigger NPE\n            DecodedJWT jwt = JWT.require(null)\n                                .build()\n                                .verify(\"dummy.token\");\n            Assert.fail(\"Expected exception to be thrown\");\n        } catch (NullPointerException e) {\n            // This should be caught in fixed code\n            // Test will pass for fixed code and fail for buggy code\n        } catch (Exception e) {\n            // Any other exception means the test fails\n            Assert.fail(\"Unexpected exception type: \" + e.getClass());\n        }\n    }\n\n    @Test\n    public void testExceptionHandlingCombination() {\n        try {\n            // This test verifies all three exception types are properly caught\n            throw new NullPointerException(\"Test NPE\");\n        } catch (JWTDecodeException | AlgorithmMismatchException | NullPointerException e) {\n            // Test will compile and pass only with fixed code\n            Assert.assertTrue(true);\n        } catch (Exception e) {\n            Assert.fail(\"Should have been caught by combined exception handler\");\n        }\n    }\n}"
  },
  {
    "commit_id": "081abd306e67395a02390e5dc16dafb2a62a0a20",
    "commit_message": "rdf4j: Fix exception handling for ParserFuzzer (#10796)\n\nIn\r\nhttps://github.com/eclipse/rdf4j/blob/main/core/queryparser/sparql/src/main/java/org/eclipse/rdf4j/query/parser/sparql/BaseDeclProcessor.java#L73,\r\nthe method throws an IllegalArgumentException when the input does not\r\nfulfil some of the conditions which could happen when we fuzz the\r\nproject. This PR fixes the fuzzer by capturing the exception.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/081abd306e67395a02390e5dc16dafb2a62a0a20",
    "buggy_code": "} catch (MalformedQueryException e1) {",
    "fixed_code": "} catch (MalformedQueryException | IllegalArgumentException e1) {",
    "patch": "@@ -28,7 +28,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       SPARQLParser obj = new SPARQLParser();\n       obj.parseQuery(\n           data.consumeString(data.remainingBytes() / 2), data.consumeRemainingAsString());\n-    } catch (MalformedQueryException e1) {\n+    } catch (MalformedQueryException | IllegalArgumentException e1) {\n     }\n   }\n }",
    "TEST_CASE": "import org.eclipse.rdf4j.query.parser.sparql.SPARQLParser;\nimport org.eclipse.rdf4j.query.MalformedQueryException;\nimport org.junit.Test;\n\npublic class BaseDeclProcessorTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testParserWithInvalidInput() throws Exception {\n        SPARQLParser parser = new SPARQLParser();\n        \n        // This input should trigger IllegalArgumentException in BaseDeclProcessor\n        // but would be uncaught in the buggy version\n        String invalidQuery = \"BASE <invalid uri>\";\n        \n        try {\n            parser.parseQuery(invalidQuery, null);\n        } catch (MalformedQueryException e) {\n            // In buggy version, this would catch MalformedQueryException but not IllegalArgumentException\n            throw new AssertionError(\"Buggy version doesn't catch IllegalArgumentException\");\n        }\n    }\n\n    @Test\n    public void testParserHandlesBothExceptions() {\n        SPARQLParser parser = new SPARQLParser();\n        \n        // Test with input that would throw MalformedQueryException\n        try {\n            parser.parseQuery(\"INVALID SPARQL SYNTAX\", null);\n        } catch (Exception e) {\n            assert e instanceof MalformedQueryException;\n        }\n        \n        // Test with input that would throw IllegalArgumentException\n        try {\n            parser.parseQuery(\"BASE <invalid uri>\", null);\n        } catch (Exception e) {\n            assert e instanceof IllegalArgumentException;\n        }\n    }\n}"
  },
  {
    "commit_id": "cce8e5a5f06f0c8157cfcb39b233dd1c80d396a7",
    "commit_message": "joni: Fix exception handling for fuzzer (#10788)\n\nFix exception handling for RegexMatcherFuzzer and AddrListFixFuzzer.\r\n\r\n---------\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/cce8e5a5f06f0c8157cfcb39b233dd1c80d396a7",
    "buggy_code": "} catch (SyntaxException | InternalException e) {",
    "fixed_code": "} catch (SyntaxException | InternalException | IllegalArgumentException e) {",
    "patch": "@@ -32,7 +32,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       Integer int2 = data.consumeInt();\n       Regex obj = new Regex(data.consumeString(data.remainingBytes() / 2));\n       obj.matcher(data.consumeRemainingAsBytes(), int1, int2);\n-    } catch (SyntaxException | InternalException e) {\n+    } catch (SyntaxException | InternalException | IllegalArgumentException e) {\n     }\n   }\n }",
    "TEST_CASE": "import org.junit.Test;\nimport org.joni.Regex;\nimport org.joni.exception.SyntaxException;\nimport org.joni.exception.InternalException;\nimport java.util.regex.PatternSyntaxException;\n\npublic class RegexMatcherFuzzerTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIllegalArgumentExceptionHandling() throws Exception {\n        // This test should pass on fixed code (handles IllegalArgumentException)\n        // and fail on buggy code (uncaught IllegalArgumentException)\n        \n        // Create a regex that will throw IllegalArgumentException when invalid parameters are passed\n        Regex regex = new Regex(\"valid pattern\");\n        \n        // Force IllegalArgumentException by passing invalid parameters to matcher()\n        // Negative start position should trigger IllegalArgumentException\n        regex.matcher(\"input\".getBytes(), -1, 0);\n    }\n\n    @Test\n    public void testOtherExceptionsHandled() throws Exception {\n        // Verify other exceptions are still properly caught\n        try {\n            // This should throw SyntaxException for invalid pattern\n            new Regex(\"invalid[pattern\");\n            throw new AssertionError(\"Expected SyntaxException not thrown\");\n        } catch (SyntaxException e) {\n            // Expected\n        }\n    }\n}"
  },
  {
    "commit_id": "6e9dea35ae13a64f44b9cfe028ae5e4febd49cbf",
    "commit_message": "graphql-java: Fix exception handling for fuzzer (#10782)\n\nFix exception handling for GraphqlFuzzer.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/6e9dea35ae13a64f44b9cfe028ae5e4febd49cbf",
    "buggy_code": "} catch (GraphQLException e) {",
    "fixed_code": "} catch (GraphQLException | ClassCastException e) {",
    "patch": "@@ -40,7 +40,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       }\n \n       GraphQL.newGraphQL(graphQLSchema).build().execute(data.consumeRemainingAsString());\n-    } catch (GraphQLException e) {\n+    } catch (GraphQLException | ClassCastException e) {\n       // Known exception\n     }\n   }",
    "TEST_CASE": "import graphql.GraphQL;\nimport graphql.GraphQLException;\nimport graphql.schema.GraphQLSchema;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.when;\n\npublic class GraphQLFuzzerTest {\n\n    @Test\n    public void testFuzzerHandlesClassCastException() {\n        // Setup test that would trigger ClassCastException\n        FuzzedDataProvider mockDataProvider = Mockito.mock(FuzzedDataProvider.class);\n        when(mockDataProvider.consumeRemainingAsString()).thenReturn(\"invalid data causing ClassCastException\");\n        \n        GraphQLSchema mockSchema = Mockito.mock(GraphQLSchema.class);\n        GraphQL graphQL = GraphQL.newGraphQL(mockSchema).build();\n        \n        try {\n            // This should throw ClassCastException which should be caught in fixed version\n            graphQL.execute(mockDataProvider.consumeRemainingAsString());\n            \n            // If we get here, the exception wasn't thrown - which is fine for this test\n            // since we're testing the catch block, not the exception throwing\n        } catch (ClassCastException e) {\n            // This is expected in fixed version\n            // Test will pass for fixed code\n        } catch (GraphQLException e) {\n            // This is expected in buggy version\n            fail(\"ClassCastException should be caught, but was wrapped in GraphQLException\");\n        } catch (Exception e) {\n            fail(\"Unexpected exception type: \" + e.getClass().getName());\n        }\n    }\n}\n\n// Mock interface to match the fuzzer test signature\ninterface FuzzedDataProvider {\n    String consumeRemainingAsString();\n}"
  },
  {
    "commit_id": "5400dc181361661dc1657d73161a62d0ee5e2486",
    "commit_message": "ohc: Fix ohc fuzzer (#10781)\n\nFix exception handling of ohc fuzzer.\r\n\r\nSigned-off-by: Arthur Chan <arthur.chan@adalogics.com>",
    "commit_url": "https://github.com/google/oss-fuzz/commit/5400dc181361661dc1657d73161a62d0ee5e2486",
    "buggy_code": "| InterruptedException | ExecutionException e) {",
    "fixed_code": "| InterruptedException | ExecutionException | IllegalStateException e) {",
    "patch": "@@ -108,7 +108,7 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       wbc.close();\n       ohCache.close();\n     } catch (IllegalArgumentException | UnsupportedOperationException | IOException\n-        | InterruptedException | ExecutionException e) {\n+        | InterruptedException | ExecutionException | IllegalStateException e) {\n       // Known exception\n     }\n   }",
    "TEST_CASE": "import org.junit.Test;\nimport org.mockito.Mockito;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class OhcFuzzerTest {\n\n    @Test(expected = IllegalStateException.class)\n    public void testFuzzerHandlesIllegalStateException() throws Exception {\n        // Create a mock Future that throws IllegalStateException\n        Future<?> mockFuture = Mockito.mock(Future.class);\n        Mockito.when(mockFuture.get(Mockito.anyLong(), Mockito.any(TimeUnit.class)))\n               .thenThrow(new IllegalStateException(\"Test exception\"));\n\n        // Simulate the scenario that would occur in the fuzzer\n        // where get() is called on a Future and throws IllegalStateException\n        try {\n            mockFuture.get(1, TimeUnit.SECONDS);\n        } catch (InterruptedException | ExecutionException | IllegalStateException e) {\n            // This should be caught in the fixed version, but throw for the test\n            throw e;\n        }\n    }\n\n    @Test\n    public void testFuzzerHandlesOtherExceptions() throws Exception {\n        // Create a mock Future that throws ExecutionException (already handled in both versions)\n        Future<?> mockFuture = Mockito.mock(Future.class);\n        Mockito.when(mockFuture.get(Mockito.anyLong(), Mockito.any(TimeUnit.class)))\n               .thenThrow(new ExecutionException(\"Test exception\", null));\n\n        try {\n            mockFuture.get(1, TimeUnit.SECONDS);\n        } catch (InterruptedException | ExecutionException e) {\n            // Expected behavior - test passes\n        } catch (IllegalStateException e) {\n            // Shouldn't happen in this test case\n            throw new AssertionError(\"Unexpected IllegalStateException\");\n        }\n    }\n}"
  },
  {
    "commit_id": "0c9df2ec8b18174ae48c1d6e3eb88deba6f1de81",
    "commit_message": "gson: catch highest level exceptions (#6792)\n\n* gson: catch highest level exception\r\n\r\nThis should fix\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40795\r\n\r\nSigned-off-by: David Korczynski <david@adalogics.com>\r\n\r\n* gson: catch all exceptions. This should fix https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40787",
    "commit_url": "https://github.com/google/oss-fuzz/commit/0c9df2ec8b18174ae48c1d6e3eb88deba6f1de81",
    "buggy_code": "} catch (JsonSyntaxException expected) { }",
    "fixed_code": "} catch (JsonParseException expected) { }",
    "patch": "@@ -22,6 +22,6 @@ public class FuzzParse {\n   public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n     try {\n       JsonParser.parseString(data.consumeRemainingAsString());\n-    } catch (JsonSyntaxException expected) { }\n+    } catch (JsonParseException expected) { }\n   }\n }",
    "TEST_CASE": "import com.google.gson.JsonParseException;\nimport com.google.gson.JsonParser;\nimport org.junit.Test;\n\npublic class FuzzParseTest {\n\n    @Test\n    public void testCatchesJsonParseException() {\n        // This input should trigger a JsonParseException (parent class)\n        String invalidJson = \"{malformed: json}\";\n        \n        try {\n            JsonParser.parseString(invalidJson);\n            // If we get here, the exception wasn't caught - test fails\n            throw new AssertionError(\"Expected JsonParseException to be caught\");\n        } catch (JsonParseException expected) {\n            // Test passes - exception was caught\n        } catch (Exception unexpected) {\n            // Any other exception means the test fails\n            throw new AssertionError(\"Expected JsonParseException but got \" + unexpected.getClass());\n        }\n    }\n\n    @Test\n    public void testCatchesJsonSyntaxException() {\n        // This input should trigger a JsonSyntaxException (child class)\n        String invalidJson = \"{\\\"key\\\": malformed}\";\n        \n        try {\n            JsonParser.parseString(invalidJson);\n            // If we get here, the exception wasn't caught - test fails\n            throw new AssertionError(\"Expected JsonSyntaxException to be caught\");\n        } catch (JsonParseException expected) {\n            // Test passes - exception was caught (JsonSyntaxException is subclass)\n        } catch (Exception unexpected) {\n            // Any other exception means the test fails\n            throw new AssertionError(\"Expected JsonParseException but got \" + unexpected.getClass());\n        }\n    }\n}"
  },
  {
    "commit_id": "0c9df2ec8b18174ae48c1d6e3eb88deba6f1de81",
    "commit_message": "gson: catch highest level exceptions (#6792)\n\n* gson: catch highest level exception\r\n\r\nThis should fix\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40795\r\n\r\nSigned-off-by: David Korczynski <david@adalogics.com>\r\n\r\n* gson: catch all exceptions. This should fix https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40787",
    "commit_url": "https://github.com/google/oss-fuzz/commit/0c9df2ec8b18174ae48c1d6e3eb88deba6f1de81",
    "buggy_code": "} catch (JsonSyntaxException | IOException expected) { }",
    "fixed_code": "} catch (JsonSyntaxException | IllegalStateException | NumberFormatException | IOException expected) { }",
    "patch": "@@ -30,6 +30,6 @@ public static void fuzzerTestOneInput(FuzzedDataProvider data) {\n       while (reader.peek() != JsonToken.END_DOCUMENT) {\n         adapter.read(reader);\n       }\n-    } catch (JsonSyntaxException | IOException expected) { }\n+    } catch (JsonSyntaxException | IllegalStateException | NumberFormatException | IOException expected) { }\n   }\n }",
    "TEST_CASE": "import com.google.gson.JsonSyntaxException;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.TypeAdapter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport org.junit.Test;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.*;\n\npublic class GsonExceptionHandlingTest {\n\n    @Test\n    public void testHandlesIllegalStateException() throws IOException {\n        // Setup\n        JsonReader reader = new JsonReader(new StringReader(\"invalid\"));\n        TypeAdapter<Object> adapter = mock(TypeAdapter.class);\n        \n        // Mock adapter.read() to throw IllegalStateException\n        when(adapter.read(reader)).thenThrow(new IllegalStateException(\"test\"));\n\n        try {\n            // Exercise\n            while (reader.peek() != JsonToken.END_DOCUMENT) {\n                adapter.read(reader);\n            }\n        } catch (IllegalStateException e) {\n            // This should be caught in fixed code, so reaching here means buggy code\n            fail(\"IllegalStateException should be caught by the handler\");\n        }\n        // If fixed, test passes as exception is caught\n    }\n\n    @Test\n    public void testHandlesNumberFormatException() throws IOException {\n        // Setup\n        JsonReader reader = new JsonReader(new StringReader(\"invalid\"));\n        TypeAdapter<Object> adapter = mock(TypeAdapter.class);\n        \n        // Mock adapter.read() to throw NumberFormatException\n        when(adapter.read(reader)).thenThrow(new NumberFormatException(\"test\"));\n\n        try {\n            // Exercise\n            while (reader.peek() != JsonToken.END_DOCUMENT) {\n                adapter.read(reader);\n            }\n        } catch (NumberFormatException e) {\n            // This should be caught in fixed code, so reaching here means buggy code\n            fail(\"NumberFormatException should be caught by the handler\");\n        }\n        // If fixed, test passes as exception is caught\n    }\n}"
  }
]